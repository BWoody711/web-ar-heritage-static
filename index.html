<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Local History AR</title>
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script
      type="text/javascript"
      src="https://raw.githack.com/AR-js-org/AR.js/master/three.js/build/ar-threex-location-only.js"
    ></script>
    <script
      type="text/javascript"
      src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"
    ></script>
    <script src="https://unpkg.com/aframe-look-at-component@0.8.0/dist/aframe-look-at-component.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <style>
      video {
        padding: 0;
        margin: 0;
        /* width: 100%; */
        height: 100vh;
        position: fixed;
        top: 0;
        z-index: 1;
      }
      body {
        margin: 0;
        padding: 0;
      }
      .thumbMenu {
        position: fixed;
        bottom: 0;
        height: 10vh;
        width: 100%;
        display: grid;
        grid-template-columns: auto auto auto;
        z-index: 3;
      }
      .thumbButton {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
        z-index: 3;
      }
      a-scene {
        /* height: 100%; */
        z-index: 2;
      }
    </style>
  </head>
  <body>
    <script>
      function backToMap() {
        window.location.href = "https://atlas.digitalhistory.ca";
      }

      let geofence_buffer = turf.polygon([
        [
          [0, 0],
          [0, 0.1],
          [0.1, 0.1],
          [0.1, 0],
          [0, 0],
        ],
      ]);

      let gps = turf.point([-1, -1]);

      let buildings = [];

      async function getBuildings(bbox) {
        const bbox_string =
          bbox.geometry.coordinates[0][0][0].toString() +
          "," +
          bbox.geometry.coordinates[0][0][1].toString() +
          "," +
          bbox.geometry.coordinates[0][1][0].toString() +
          "," +
          bbox.geometry.coordinates[0][2][1].toString();
        const res = await fetch(
          "https://atlas.digitalhistory.ca/api/buildings/?bbox=" + bbox_string
        );
        const data = await res.json();
        return data;
      }

      let objects = [];

      function parseBuildings(bbox) {
        getBuildings(bbox)
          .then((buildings) => {
            let scene = document.querySelector("a-scene");
            if (objects.length > 0) {
              alert(JSON.stringify(objects));
              for (let y = 0; y < objects.length; y++) {
                document.getElementById(objects[y].id).outerHTML = "";
              }
              objects = [];
            }
            for (let x = 0; x < buildings.features.length; x++) {
              const id = buildings.features[x].properties.id;

              const entity = document.createElement("a-cylinder");
              const point = turf.toWgs84(
                turf.point(buildings.features[x].geometry.coordinates)
              );
              entity.setAttribute("gps-new-entity-place", {
                latitude: point.geometry.coordinates[1],
                longitude: point.geometry.coordinates[0],
              });
              objects.push({ id: id });
              // entity.setAttribute("look-at", "[gps-new-camera]");
              // entity.setAttribute("scale", {
              //   x: 5,
              //   y: 5,
              //   z: 5,
              // });
              entity.setAttribute("id", id);
              entity.setAttribute("radius", 1);
              entity.setAttribute("height", 0.2);
              entity.setAttribute("rotation", {
                x: 270,
                y: 0,
                z: 0,
              });
              entity.setAttribute("color", "white");
              // entity.addEventListener("markerFound", () => {
              //   let markerPosition = entity.object3D.position;
              //   let cameraPosition =
              //     document.querySelector("[camera]").object3D.position;
              //   let distance = cameraPosition.distanceTo(markerPosition);
              //   check = setInterval(() => {
              //     cameraPosition = camera.object3D.position;
              //     markerPosition = marker.object3D.position;
              //     distance = cameraPosition.distanceTo(markerPosition);
              //     if (distance < 50) {
              //       entity.setAttribute("color", "blue");
              //       alert(entity.id);
              //     }
              //   }, 1000);
              // });
              // entity.addEventListener("markerLost", () => {
              //   clearInterval(check);
              // });
              // alert(entity.outerHTML.toString());
              scene.appendChild(entity);
            }
          })
          .catch((err) => {
            alert(err);
          });
      }

      function createGeofence() {
        console.log("Updating geofence...");
        const geo_buffer = turf.toMercator(
          turf.bboxPolygon(
            turf.bbox(turf.buffer(gps, 200, { units: "meters" }))
          )
        );
        const building_bbox = turf.toMercator(
          turf.bboxPolygon(
            turf.bbox(turf.buffer(gps, 300, { units: "meters" }))
          )
        );
        parseBuildings(building_bbox);
        return geo_buffer;
      }

      function checkGeofence(position) {
        console.log("Checking geofence...");
        if (position.coords.latitude && position.coords.longitude) {
          gps = turf.point([
            position.coords.longitude,
            position.coords.latitude,
          ]);
          console.log(gps);
          var in_geofence = turf.booleanPointInPolygon(
            gps,
            turf.toWgs84(geofence_buffer)
          );
          if (!in_geofence) {
            geofence_buffer = createGeofence();
          }
        }
      }

      function geofenceUpdate() {
        if ("geolocation" in navigator) {
          navigator.geolocation.getCurrentPosition(checkGeofence);
        } else {
          clearInterval(geofenceChecker);
          console.log(
            "GPS is not enabled or configured properly on your device."
          );
        }
      }

      const geofenceChecker = setInterval(() => {
        geofenceUpdate();
      }, 10000);

      // function onCameraMove(e) {
      //   // const cameraPosition =
      //   //   document.querySelector("[camera]").object3D.position;
      //   // let entity;
      //   // let distance;
      //   // for (let x = 0; x < objects.length; x++) {
      //   //   entity = document.getElementById(objects[y].id);
      //   //   distance = cameraPosition.distanceTo(entity);
      //   //   //Fix this so that it only ever picks one icon
      //   //   if (distance < 25) {
      //   //     alert(objects[y].id);
      //   //     entity.setAttribute("color", "blue");
      //   //   } else {
      //   //     entity.setAttribute("color", "white");
      //   //   }
      //   // }
      // }

      async function fetchBuildingInfo(id) {
        const res = await fetch(
          `https://atlas.digitalhistory.ca/api/building/${id}/`
        );
        const building = await res.json();
        alert(JSON.stringify(building));
      }

      window.onload = () => {
        geofenceUpdate();
        let testEntityAdded = false;

        let camera = document.querySelector("a-camera");
        camera.addEventListener("gps-camera-update-position", (e) => {
          if (!testEntityAdded) {
            //lon, lat
            alert(JSON.stringify(e.detail.position));
            let buildings = document.getElementsByTagName("a-cylinder");
            let distance;
            let id = 0;
            //Reduce this distance threshold to at most 50
            let minDistance = 500;
            for (let x = 0; x < buildings.length; x++) {
              distance = camera.object3D.position.distanceTo(
                buildings[x].object3D.position
              );
              if (distance < minDistance) {
                minDistance = distance;
                id = buildings[x].id;
              }
            }
            if (id > 0) {
              if (document.getElementById(id).getAttribute("color") != "blue") {
                document
                  .querySelectorAll('[color="blue"]')[0]
                  .setAttribute("color", "white");
                document.getElementById(id).setAttribute("color", "blue");
                fetchBuildingInfo(id);
              }
            }
          }
          testEntityAdded = true;
        });
      };
    </script>
    <div>
      <a-scene
        vr-mode-ui="enabled: false"
        arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: true"
        renderer="antialias: true; alpha: true"
      >
        <!-- Reduce max distance to 50 later -->
        <a-camera
          look-controls-enabled="false"
          arjs-device-orientation-controls="smoothingFactor: 0.1"
          gps-new-camera="gpsMinDistance: 1; maxDistance: 200; positionMinAccuracy: 100; alert: true"
        ></a-camera>
        <!-- <a-entity
          material="color: red"
          geometry="primitive: box"
          gps-new-entity-place="latitude: 43.462716; longitude: -80.542271"
          scale="15 15 15"
          position="0 20 0"
        ></a-entity> -->
      </a-scene>
      <div class="thumbMenu">
        <button class="thumbButton">Description</button>
        <button class="thumbButton">Images</button>
        <button class="thumbButton" onclick="backToMap()">Back to Map</button>
      </div>
    </div>
  </body>
</html>
